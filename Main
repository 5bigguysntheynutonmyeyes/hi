
do -- Folders
    if not isfolder("Lotti") then
        makefolder("Lotti")
    end
    --
    if not isfolder("Lotti/Images") then
        makefolder("Lotti/Images")
    end
    --
    if not isfolder("Lotti/Configs") then
        makefolder("Lotti/Configs")
    end
end

local Player = game:GetService("Players").LocalPlayer
local Players = game:GetService("Players")
local Char = Player.Character or Player.CharacterAdded
local Humanoid = Char:FindFirstChildOfClass("Humanoid")
local HumanoidRootPart = Char:FindFirstChild("HumanoidRootPart")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

getgenv().Expander = false
getgenv().ExpanderSize = 5
getgenv().ExpanderTransparency = 0.5
getgenv().Expander2 = false
getgenv().ExpanderSize2 = 5
getgenv().ExpanderTransparency2 = 0.5

Player.CharacterAdded:Connect(function(character)
    Char = character
end)

-- // Tables
local Library, Utility = loadfile("lottiui.lua")()
local Flags = Library.pointers
local Color, Math, Lotti = {}, {Conversions = {}}, {Configs = {},Drawings = {},
    Locals = {
        LastStutter = tick(),
        TriggerTick = tick(),
        AimAssistFOV = 100,
        DeadzoneFOV = 90,
        PartSizes = {
            ["Head"] = Vector3.new(2, 1, 1),
            ["Torso"] = Vector3.new(2, 2, 1),
            ["Left Arm"] = Vector3.new(1, 2, 1),
            ["Right Arm"] = Vector3.new(1, 2, 1),
            ["Left Leg"] = Vector3.new(1, 2, 1),
            ["Right Leg"] = Vector3.new(1, 2, 1)
        }
    },
    Safe = false,
    Version = "Legit",
    Account = {
        Username = (lgVarsTbl and lgVarsTbl["DiscordUsername"] or "Lotti"),
        UserID = 1
    }
}
local Visuals = {
    Bases = {};
    Base = {};
}
-- // Variables
local ReplicatedStorage, UserInputService, TeleportService, HttpService, RunService, Workspace, Lighting, CoreGui, Players, Teams, Stats = game:GetService("ReplicatedStorage"), game:GetService("UserInputService"), game:GetService("TeleportService"), game:GetService("HttpService"), game:GetService("RunService"), game:GetService("Workspace"), game:GetService("Lighting"), game:GetService("CoreGui"), game:GetService("Players"), game:GetService("Teams"), game:GetService("Stats")
--
local UserGameSettings = UserSettings():GetService("UserGameSettings")
--
local Client = Players.LocalPlayer
--
local ResetMemoryCategory, SetMemoryCategory, SetUpvalueName, SetMetatable, ProfileBegin, GetMetatable, GetConstants, GetRegistry, GetUpvalues, GetConstant, SetConstant, GetUpvalue, ValidLevel, LoadModule, SetUpvalue, ProfileEnd, GetProtos, GetLocals, Traceback, SetStack, GetLocal, DumpHeap, GetProto, SetLocal, GetStack, GetFenv, GetInfo, Info = debug.resetmemorycategory, debug.setmemorycategory, debug.setupvaluename, debug.setmetatable, debug.profilebegin, debug.getmetatable, debug.getconstants, debug.getregistry, debug.getupvalues, debug.getconstant, debug.setconstant, debug.getupvalue, debug.validlevel, debug.loadmodule, debug.setupvalue, debug.profileend, debug.getprotos, debug.getlocals, debug.traceback, debug.setstack, debug.getlocal, debug.dumpheap, debug.getproto, debug.setlocal, debug.getstack, debug.getfenv, debug.getinfo, debug.info
local RandomSeed, Random, Frexp, Floor, Atan2, Log10, Noise, Round, Ldexp, Clamp, Sinh, Sign, Asin, Acos, Fmod, Huge, Tanh, Sqrt, Atan, Modf, Ceil, Cosh, Deg, Min, Log, Cos, Exp, Max, Rad, Abs, Pow, Sin, Tan, Pi = math.randomseed, math.random, math.frexp, math.floor, math.atan2, math.log10, math.noise, math.round, math.ldexp, math.clamp, math.sinh, math.sign, math.asin, math.acos, math.fmod, math.huge, math.tanh, math.sqrt, math.atan, math.modf, math.ceil, math.cosh, math.deg, math.min, math.log, math.cos, math.exp, math.max, math.rad, math.abs, math.pow, math.sin, math.tan, math.pi
local Foreachi, Isfrozen, Foreach, Insert, Remove, Concat, Freeze, Create, Unpack, Clear, Clone, Maxn, Move, Pack, Find, Sort, Getn = table.foreachi, table.isfrozen, table.foreach, table.insert, table.remove, table.concat, table.freeze, table.create, table.unpack, table.clear, table.clone, table.maxn, table.move, table.pack, table.find, table.sort, table.getn
local PackSize, Reverse, SUnpack, Gmatch, Format, Lower, Split, Match, Upper, Byte, Char, Pack, Gsub, SFind, Rep, Sub, Len = string.packsize, string.reverse, string.unpack, string.gmatch, string.format, string.lower, string.split, string.match, string.upper, string.byte, string.char, string.pack, string.gsub, string.find, string.rep, string.sub, string.len
local Countlz, Rrotate, Replace, Lrotate, Countrz, Arshift, Extract, Lshift, Rshift, Btest, Band, Bnot, Bxor, Bor = bit32.countlz, bit32.rrotate, bit32.replace, bit32.lrotate, bit32.countrz, bit32.arshift, bit32.extract, bit32.lshift, bit32.rshift, bit32.btest, bit32.band, bit32.bnot, bit32.bxor, bit32.bor
local NfcNormalize, NfdNormalize, CharPattern, CodePoint, Graphemes, Offset, Codes, Char, Len = utf8.nfcnormalize, utf8.nfdnormalize, utf8.charpattern, utf8.codepoint, utf8.graphemes, utf8.offset, utf8.codes, utf8.char, utf8.len
local Isyieldable, Running, Status, Create, Resume, Close, Yield, Wrap = coroutine.isyieldable, coroutine.running, coroutine.status, coroutine.create, coroutine.resume, coroutine.close, coroutine.yield, coroutine.wrap
local Desynchronize, Synchronize, Cancel, Delay, Defer, Spawn, Wait = task.desynchronize, task.synchronize, task.cancel, task.delay, task.defer, task.spawn, task.wait
--

--
local Ping = Stats.PerformanceStats.Ping
-- // Preset
do
    do -- Renders
        for Index = 1, 2 do
            local Circle = (Index == 1 and "AimAssist" or "Deadzone")
            --
            Visuals[Circle .. "Circle"] = Drawing.new("Circle")
            setrenderproperty(Visuals[Circle .. "Circle"], "Filled", true)
            setrenderproperty(Visuals[Circle .. "Circle"], "ZIndex", 59)
            --
            Visuals[Circle .. "Outline"] = Drawing.new("Circle")
            setrenderproperty(Visuals[Circle .. "Outline"], "Thickness", 1.5)
            setrenderproperty(Visuals[Circle .. "Outline"], "Filled", false)
            setrenderproperty(Visuals[Circle .. "Outline"], "ZIndex", 60)
        end
    end
end
-- // Functions
do -- Utility
    function Utility:GetTableIndexes(Table, Custom)
        local Table2 = {}
        --
        for Index, Value in pairs(Table) do
            Table2[Custom and Value[1] or #Table2 + 1] = Index 
        end
        --
        return Table2
    end
    --
    function Utility:ConvertTable(Table1)
        local Table2 = {}
        --
        for Index, Value in pairs(Table1) do
            Table2[typeof(Index) ~= "number" and Index or (#Table2 + 1)] = tostring(Value)
        end
        --
        return Table2
    end
    --
    function Utility:ConvertString(Value)
        if typeof(Value) == "Color3" then
            Value = Value:ToHex()
        end
        --
        return Value
    end
    --
    function Utility:ClampString(String, Length, Font)
        local Font = (Font or 2)
        local Split = String:split("\n")
        --
        local Clamped = ""
        --
        for Index, Value2 in pairs(Split) do
            if (Index * 13) <= Length then
                Clamped = Clamped .. Value2 .. (Index == #Split and "" or "\n")
            end
        end
        --
        return (Clamped ~= String and (Clamped == "" and "" or Clamped:sub(0, #Clamped - 1) .. " ...") or Clamped)
    end
    --
    function Utility:ThreadFunction(Func, Name, ...)
        local Func = Name and function()
            local Passed, Statement = pcall(Func)
            --
            if not Passed and not Lotti.Safe then
                warn("Lotti:\n", "              " .. Name .. ":", Statement)
            end
        end or Func
        local Thread = Create(Func)
        --
        Resume(Thread, ...)
        return Thread
    end
    --
    function Utility:TableToString(Table)
        if #Table > 1 then
            local Text = ""
            --
            for Index, Value in pairs(Table) do
                Text = Text .. Value .. "\n"
            end
            --
            return Text:sub(0, #Text - 1)
        else
            return Table[1]
        end
    end
    --
    function Utility:MousePosition(Offset)
        if Offset then
            return UserInputService:GetMouseLocation() + Lotti:CursorOffset()
        else
            return UserInputService:GetMouseLocation()
        end
    end  
    --
    function Utility:Console(Action, ...)
        if not Lotti.Safe then
            Action(...)
        end
    end
    --
    function Utility:ToHitboxes(Hitboxes)
        if Hitboxes == "Upper Top" then
            return {"Head", "Torso"}
        elseif Hitboxes == "Top" then
            return {"Head", "Torso", "Arms"}
        elseif Hitboxes == "Lower" then
            return {"Torso", "Arms", "Legs"}
        elseif Hitboxes == "All" then
            return {"Head", "Torso", "Arms", "Legs"}
        else
            return {Hitboxes}
        end
    end
    --
    function Utility:ReadjustmentActive(Active)
        if Active then
            return UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
        end
        --
        return false
    end
end
--
do -- Color
	function Color:Multiply(Color, Multiplier)
		return Color3.new(Color.R * Multiplier, Color.G * Multiplier, Color.B * Multiplier)
	end
    --
	function Color:Add(Color, Addition)
		return Color3.new(Color.R + Addition, Color.G + Addition, Color.B + Addition)
	end
    --
    function Color:Lerp(Value, MinColor, MaxColor)
        if Value <= 0 then return MaxColor end
        if Value >= 100 then return MinColor end
        --
        return Color3.new(
            MaxColor.R + (MinColor.R - MaxColor.R) * Value,
            MaxColor.G + (MinColor.G - MaxColor.G) * Value,
            MaxColor.B + (MinColor.B - MaxColor.B) * Value
        )
    end
end
--
do -- Math
    function Math:RoundVector(Vector)
        return Vector2.new(Round(Vector.X), Round(Vector.Y))
    end
    --
    function Math:Shift(Number)
        return Acos(Cos(Number * Pi)) / Pi
    end
    --
    function Math:Random(Number)
        return Random(-Number, Number)
    end
    --
    function Math:RandomVec3(X, Y, Z)
        return Vector3.new(Math:Random(X), Math:Random(Y), Math:Random(Z))
    end
end
--
do -- Lotti
    function Lotti:Unload()
        Lotti.Locals.Window:Unload()
    end
    --
    function Lotti:GetCharacter(Player)
        return Player.Character
    end
    --
    function Lotti:GetHumanoid(Player, Character)
        return Character:FindFirstChildOfClass("Humanoid")
    end
    --
    function Lotti:GetHealth(Player, Character, Humanoid)
        if Humanoid then
            return Clamp(Humanoid.Health, 0, Humanoid.MaxHealth), Humanoid.MaxHealth
        end
    end
    --
    function Lotti:GetJumpPower(Player, Chareacter, Humanoid)
        return Humanoid.JumpPower
    end
    --
    function Lotti:GetRootPart(Player, Character, Humanoid)
        return Humanoid.RootPart
    end
    --
    function Lotti:GetLatency()
        return (Ping:GetValue() / 1000)
    end
    --
    function Lotti:GetTeam(Player)
        return Player.Team
    end
    --
    function Lotti:GetPlayerParent(Player)
        return Player.Parent
    end
    --
    function Lotti:CheckTeam(Player1, Player2)
        return (Lotti:GetTeam(Player1) ~= Lotti:GetTeam(Player2))
    end
    --
    function Lotti:GetIgnore(Unpacked)
        if Unpacked then
            return
        else
            return {}
        end
    end
    --
    function Lotti:GetOrigin(Origin)
        if Origin == "Head" then
            local Object, Humanoid, RootPart = Lotti:ValidateClient(Client)
            local Head = Object:FindFirstChild("Head")
            --
            if Head and Head:IsA("RootPart") then
                return Head.CFrame.Position
            end
        elseif Origin == "Torso" then
            local Object, Humanoid, RootPart = Lotti:ValidateClient(Client)
            --
            if RootPart then
                return RootPart.CFrame.Position
            end
        end
        --
        return Workspace.CurrentCamera.CFrame.Position
    end
    --
    function Lotti:CursorOffset()
        if (Flags["LegitMisc_CursorOffset"]:Get()) then
            local CursorOffsetX = tonumber(Flags["LegitMisc_CursorOffsetX"]:Get())
            local CursorOffsetY = tonumber(Flags["LegitMisc_CursorOffsetY"]:Get())
            --
            return Vector2.new(CursorOffsetX, CursorOffsetY)
        else
            return Vector2.new(0, 0)
        end
    end
    --
    function Lotti:GetBodyParts(Character, RootPart, Indexes, Hitboxes)
        local Parts = {}
        local Hitboxes = Hitboxes or {"Head", "Torso", "Arms", "Legs"}
        --
        for Index, Part in pairs(Character:GetChildren()) do
            if Part:IsA("BasePart") and Part ~= RootPart then
                if Find(Hitboxes, "Head") and Part.Name:lower():find("head") then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                elseif Find(Hitboxes, "Torso") and Part.Name:lower():find("torso") then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                elseif Find(Hitboxes, "Arms") and Part.Name:lower():find("arm") then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                elseif Find(Hitboxes, "Legs") and Part.Name:lower():find("leg") then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                elseif (Find(Hitboxes, "Arms") and Part.Name:lower():find("hand")) or (Find(Hitboxes, "Legs ") and Part.Name:lower():find("foot")) then
                    Parts[Indexes and Part.Name or #Parts + 1] = Part
                end
            end
        end
        --
        return Parts
    end
    --
    function Lotti:ClientAlive(Player, Character, Humanoid)
        local Health, MaxHealth = Lotti:GetHealth(Player, Character, Humanoid)
        --
        return (Health > 0)
    end
    --
    function Lotti:ValidateClient(Player)
        local Object = Lotti:GetCharacter(Player)
        local Humanoid = (Object and Lotti:GetHumanoid(Player, Object))
        local RootPart = (Humanoid and Lotti:GetRootPart(Player, Object, Humanoid))
        --
        return Object, Humanoid, RootPart
    end
    --
    function Lotti:GetBoundingBox(BodyParts, RootPart)
        local Size = Vector3.new(0, 0, 0)
        --
        for Index, Value in pairs({"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}) do
            local Part = BodyParts[Value]
            local PartSize = (Part and Part.Size or Lotti.Locals.PartSizes[Value])
            --
            if Value == "Head" then
                Size = (Size + Vector3.new(0, PartSize.Y, 0))
            elseif Value == "Torso" then
                Size = (Size + Vector3.new(PartSize.X, PartSize.Y, PartSize.Z))
            elseif Value == "Left Arm" then
                Size = (Size + Vector3.new(PartSize.X, 0, 0))
            elseif Value == "Right Arm" then
                Size = (Size + Vector3.new(PartSize.X, 0, 0))
            elseif Value == "Left Leg" then
                Size = (Size + Vector3.new(0, PartSize.Y, 0))
            elseif Value == "Right Leg" then
                Size = (Size + Vector3.new(0, PartSize.Y, 0))
            end
        end
        --
        return (RootPart.CFrame + Vector3.new(0, -0.125, 0)), Size
    end
    --
    function Lotti:RayCast(Part, Origin, Ignore, Distance)
        local Ignore = Ignore or {}
        local Distance = Distance or 2000
        --
        local Cast = Ray.new(Origin, (Part.Position - Origin).Unit * Distance)
        local Hit = Workspace:FindPartOnRayWithIgnoreList(Cast, Ignore)
        --
        return (Hit and Hit:IsDescendantOf(Part.Parent)) == true, Hit
    end
    --
    function Lotti:GetPlayers()
        return Players:GetPlayers()
    end
    --
    function Lotti:PlayerAdded(Player)
        Visuals:Create({Player = Player})
    end
    --
    function Lotti:GetAimAssistTarget()
        local Target = {
            Player = nil,
            Object = nil,
            Part = nil,
            Vector = nil,
            Magnitude = Huge
        }
        --
        local MouseLocation = Utility:MousePosition(true)
        --
        local FieldOfView = Flags["LegitAimAssist_FieldOfView"]:Get()
        local Origin = Flags["LegitAimAssist_WallCheckOrigin"]:Get()
        local FOVType = Flags["LegitAimAssist_FOVType"]:Get()
        local Deadzone = Flags["LegitAimAssist_DeadzoneAmmount"]:Get()
        local Hitboxes = Flags["LegitAimAssist_Hitbox"]:Get()
        --
        local TeamCheck = (table.find(Flags["LegitAimAssist_Checks"]:Get(), "Team Check") or false)
        local WallCheck = (table.find(Flags["LegitAimAssist_Checks"]:Get(), "Wall Check") or false)
        local VisibleCheck = (table.find(Flags["LegitAimAssist_Checks"]:Get(), "Visible Check") or false)
        local ForceFieldCheck = (table.find(Flags["LegitAimAssist_Checks"]:Get(), "ForceField Check") or false)
        local AliveCheck = (table.find(Flags["LegitAimAssist_Checks"]:Get(), "Alive Check") or false)
        --
        local Disabled = (Flags["LegitAimAssist_MaxFOV"]:Get() == false)
        local FieldOfView = Lotti.Locals.AimAssistFOV / 2
        local Disabled2 = (Flags["LegitAimAssist_DeadzoneAmmount"]:Get() == 0)
        local Deadzone = Lotti.Locals.DeadzoneFOV / 2
        --
        local Dynamic = 625
        local DynamicHigh = Dynamic * 2
        local DynamicLow = Dynamic / 8.5
        --
        local PossibleTarget = {
            Player = nil,
            Object = nil,
            Magnitude = Huge
        }
        --
        for Index, Player in pairs(Lotti:GetPlayers()) do
            if Player ~= Client then
                if (TeamCheck and not Lotti:CheckTeam(Client, Player)) then continue end
                --
                local Object, Humanoid, RootPart = Lotti:ValidateClient(Player)
                --
                if (Object and Humanoid and RootPart) then
                    if (ForceFieldCheck and Object:FindFirstChildOfClass("ForceField")) then continue end
                    if (AliveCheck and not Lotti:ClientAlive(Player, Character, Humanoid)) then continue end
                    --
                    local Position, Visible = Workspace.CurrentCamera:WorldToViewportPoint(RootPart.CFrame.Position)
                    local Position2 = Vector2.new(Position.X, Position.Y)
                    local Magnitude = (MouseLocation - Position2).Magnitude
                    local Distance = (Workspace.CurrentCamera.CFrame.Position - RootPart.CFrame.Position).Magnitude
                    local SelfAimAssistFOV = FieldOfView
                    local SelfDeadzoneFOV = Deadzone
                    local SelfMultiplier = 1
                    --
                    if FOVType == "Dynamic" then
                        SelfMultiplier = (Distance - DynamicLow) > 0 and (1 - ((Distance - DynamicLow) / Dynamic)) or (1 + (Clamp(Abs((Distance - DynamicLow) * 1.75), 0, DynamicHigh) / 100)) * 1.25
                    end
                    --
                    if Visible and Magnitude <= PossibleTarget.Magnitude then
                        PossibleTarget = {
                            Player = Player,
                            Object = Object,
                            Distance = Distance,
                            Multiplier = SelfMultiplier,
                            Magnitude = Magnitude
                        }
                    end
                    --
                    SelfAimAssistFOV = (SelfAimAssistFOV * SelfMultiplier)
                    SelfDeadzoneFOV = (SelfDeadzoneFOV * SelfMultiplier)
                    --
                    if ((not Disabled) and not (Magnitude <= SelfAimAssistFOV)) then continue end
                    --
                    if Visible and Magnitude <= Target.Magnitude then
                        local ClosestPart, ClosestVector, ClosestMagnitude = nil, nil, Huge
                        --
                        local Parts = {}
                        for Index, Part in pairs(Object:GetChildren()) do
                            if Part:IsA("BasePart") and Part ~= RootPart then
                                if Find(Hitboxes, "Head") and Part.Name:lower():find("head") then
                                    Parts[#Parts + 1] = Part
                                elseif Find(Hitboxes, "Torso") and Part.Name:lower():find("torso") then
                                    Parts[#Parts + 1] = Part
                                elseif Find(Hitboxes, "Arms") and Part.Name:lower():find("arm") then
                                    Parts[#Parts + 1] = Part
                                elseif Find(Hitboxes, "Legs") and Part.Name:lower():find("leg") then
                                    Parts[#Parts + 1] = Part
                                elseif (Find(Hitboxes, "Arms") and Part.Name:lower():find("hand")) or (Find(Hitboxes, "Legs ") and Part.Name:lower():find("foot")) then
                                    Parts[#Parts + 1] = Part
                                end
                            end
                        end
                        --
                        for Index2, Part in pairs(Parts) do
                            if (VisibleCheck and not (Part.Transparency ~= 1)) then continue end
                            --
                            local Position3, Visible2 = Workspace.CurrentCamera:WorldToViewportPoint(Part.CFrame.Position)
                            local Position4 = Vector2.new(Position3.X, Position3.Y)
                            local Magnitude2 = (MouseLocation - Position4).Magnitude
                            --
                            if Position4 and Visible2 then
                                if ((not Disabled) and not (Magnitude2 <= SelfAimAssistFOV)) then continue end
                                if (WallCheck and not Lotti:RayCast(Part, Lotti:GetOrigin(Origin), {Lotti:GetCharacter(Client), Lotti:GetIgnore(true)})) then continue end
                                --
                                if Magnitude2 <= ClosestMagnitude then
                                    ClosestPart = Part
                                    ClosestVector = Position4
                                    ClosestMagnitude = Magnitude2
                                end
                            end
                        end
                        --
                        if ClosestPart and ClosestVector and ClosestMagnitude then
                            Target = {
                                Player = Player,
                                Object = Object,
                                Part = ClosestPart,
                                Vector = ClosestVector,
                                Distance = Distance,
                                Multiplier = SelfMultiplier,
                                Magnitude = ClosestMagnitude,
                            }
                        end
                    end
                end
            end
        end
        --
        if Target.Player and Target.Object and Target.Part and Target.Vector and Target.Magnitude then
            PossibleTarget = {
                Player = Target.Player,
                Object = Target.Object,
                Distance = Target.Distance,
                Multiplier = Target.Multiplier,
                Magnitude = Target.Magnitude
            }
            --
            Lotti.Locals.Target = Target
        else
            Lotti.Locals.Target = nil
        end
        --
        if PossibleTarget and PossibleTarget.Distance and PossibleTarget.Multiplier then
            Lotti.Locals.PossibleTarget = PossibleTarget
        else
            Lotti.Locals.PossibleTarget = nil
        end
    end
    --
    function Lotti:GetTriggerBotTarget()
        local Targets = {}
        --
        local MouseLocation = Utility:MousePosition(true)
        --
        local Hitboxes = Flags["LegitTriggerbot_Hitbox"]:Get()
        local Origin = Flags["LegitTriggerbot_WallCheckOrigin"]:Get()
        --
        local TeamCheck = (table.find(Flags["LegitTriggerbot_Checks"]:Get(), "Team Check") or false)
        local WallCheck = (table.find(Flags["LegitTriggerbot_Checks"]:Get(), "Wall Check") or false)
        local VisibleCheck = (table.find(Flags["LegitTriggerbot_Checks"]:Get(), "Visible Check") or false)
        local ForceFieldCheck = (table.find(Flags["LegitTriggerbot_Checks"]:Get(), "ForceField Check") or false)
        local AliveCheck = (table.find(Flags["LegitTriggerbot_Checks"]:Get(), "Alive Check") or false)
        --
        for Index, Player in pairs(Lotti:GetPlayers()) do
            if Player ~= Client then
                if (TeamCheck and not Lotti:CheckTeam(Client, Player)) then continue end
                --
                local Object, Humanoid, RootPart = Lotti:ValidateClient(Player)
                --
                if (Object and Humanoid and RootPart) then
                    if (ForceFieldCheck and Object:FindFirstChildOfClass("ForceField")) then continue end
                    if (AliveCheck and not Lotti:ClientAlive(Player, Character, Humanoid)) then continue end
                    --
                    for Index2, Part in pairs(Lotti:GetBodyParts(Object, RootPart, false, Hitboxes)) do
                        if (VisibleCheck and not (Part.Transparency ~= 1)) then continue end
                        if (WallCheck and not Lotti:RayCast(Part, Lotti:GetOrigin(Origin), {Lotti:GetCharacter(Client), Lotti:GetIgnore(true)})) then continue end
                        --
                        Targets[#Targets + 1] = Part
                    end
                end
            end
        end
        --
        local PointRay = Workspace.CurrentCamera:ViewportPointToRay(MouseLocation.X, MouseLocation.Y, 0)
        local Hit, Position, Normal, Material = Workspace:FindPartOnRayWithWhitelist(Ray.new(PointRay.Origin, PointRay.Direction * 1000), Targets, false, false)
        --
        if Hit then
            Lotti.Locals.TriggerTarget = {
                Part = Hit,
                Position = Position,
                Material = Material
            }
        else
            Lotti.Locals.TriggerTarget = nil
        end
    end
    --
    function Lotti:AimAssist()
        if Lotti.Locals.Target and Lotti.Locals.Target.Part and Lotti.Locals.Target.Vector then
            local Stutter = tonumber(Flags["LegitAimAssist_Stutter"]:Get())
            local Deadzone = (Flags["LegitAimAssist_DeadzoneAmmount"]:Get() > 0)
            local Multiplier = Lotti.Locals.Target.Multiplier
            --
            local Tick = tick()
            --
            if ((Tick - Lotti.Locals.LastStutter) >= (Stutter / 1000)) and not ((not Deadzone) and not (Lotti.Locals.Target.Magnitude >= ((Lotti.Locals.DeadzoneFOV * Multiplier) / 2))) then
                Lotti.Locals.LastStutter = Tick
                --
                local MouseLocation = Utility:MousePosition(true)
                local MoveVector =  (Lotti.Locals.Target.Vector - MouseLocation)
                local Smoothness = Vector2.new((Flags["LegitAimAssist_HorizontalSmoothing"]:Get() / 2), (Flags["LegitAimAssist_VerticalSmoothing"]:Get() / 2))
                --
                local FinalVector = Math:RoundVector(Vector2.new(MoveVector.X / Smoothness.X, MoveVector.Y / Smoothness.Y))
                --
                mousemoverel(FinalVector.X, FinalVector.Y)
            end
        end
    end
    --
    function Lotti:TriggerBot()
        if Lotti.Locals.TriggerTarget then
            local Tick = tick()
            --
            local TriggerDelay = tonumber(Flags["LegitTriggerbot_Delay"]:Get())
            local Interval = tonumber(Flags["LegitTriggerbot_Interval"]:Get())
            --
            if ((Tick - Lotti.Locals.TriggerTick) >= (Interval / 1000)) then
                Lotti.Locals.TriggerTick = Tick
                --
                if TriggerDelay ~= 0 then
                    Delay(TriggerDelay / 1000, function()
                        mouse1press()
                        mouse1release()
                    end)
                else
                    mouse1press()
                    task.wait(0.05)
                    mouse1release()
                end
            end
        end
    end
    --
    function Lotti:UpdateFieldOfView()
        local ScreenSize = Workspace.CurrentCamera.ViewportSize
        --
        local FieldOfView = tonumber(Flags["LegitAimAssist_FieldOfView"]:Get())
        local Deadzone = ((Flags["LegitAimAssist_DeadzoneAmmount"]:Get() > 0) and tonumber(Flags["LegitAimAssist_DeadzoneAmmount"]:Get()) or 0)
        local Multiplier = (Lotti.Locals.PossibleTarget and Lotti.Locals.PossibleTarget.Multiplier or 1)
        --
        Lotti.Locals.AimAssistFOV = ((FieldOfView / 100) * ScreenSize.Y)
        Lotti.Locals.DeadzoneFOV = (Lotti.Locals.AimAssistFOV * 0.9) * (Deadzone / 100)
        --
        Lotti.Locals.VisualAimAssistFOV = (Lotti.Locals.AimAssistFOV * Multiplier)
        Lotti.Locals.VisualDeadzoneFOV = (Lotti.Locals.DeadzoneFOV * Multiplier)
    end
end
--
do -- Visuals
    function Visuals:Create(Properties)
        if Properties then
            if Properties.Player then
                local Self = setmetatable({
                    Player = Properties.Player,
                    Info = {
                        Tick = tick()
                    },
                    Renders = {
                        Weapon = Drawing.new("Text"),
                        Distance = Drawing.new("Text"),
                        HealthBarOutline = Drawing.new("Square"),
                        HealthBarInline = Drawing.new("Square"),
                        HealthBarValue = Drawing.new("Text"),
                        BoxFill = Drawing.new("Square"),
                        BoxOutline = Drawing.new("Square"),
                        BoxInline = Drawing.new("Square"),
                        Name = Drawing.new("Text")
                    }
                }, {
                    __index = Visuals.Base
                })
                --
                do -- Renders.Name
                    setrenderproperty(Self.Renders.Name, "Text", Self.Player.Name)
                    setrenderproperty(Self.Renders.Name, "Size", 13)
                    setrenderproperty(Self.Renders.Name, "Center", true)
                    setrenderproperty(Self.Renders.Name, "Outline", true)
                    setrenderproperty(Self.Renders.Name, "Font", 2)
                    setrenderproperty(Self.Renders.Name, "Visible", false)
                end
                --
                do -- Renders.Box
                    -- Inline
                    setrenderproperty(Self.Renders.BoxInline, "Thickness", 1.25)
                    setrenderproperty(Self.Renders.BoxInline, "Filled", false)
                    setrenderproperty(Self.Renders.BoxInline, "Visible", false)
                    -- Outline
                    setrenderproperty(Self.Renders.BoxOutline, "Thickness", 2.5)
                    setrenderproperty(Self.Renders.BoxOutline, "Filled", false)
                    setrenderproperty(Self.Renders.BoxOutline, "Visible", false)
                    -- Fill
                    setrenderproperty(Self.Renders.BoxFill, "Filled", true)
                    setrenderproperty(Self.Renders.BoxFill, "Visible", false)
                end
                --
                do -- Renders.HealthBar
                    -- Inline
                    setrenderproperty(Self.Renders.HealthBarInline, "Filled", true)
                    setrenderproperty(Self.Renders.HealthBarInline, "Visible", false)
                    -- Outline
                    setrenderproperty(Self.Renders.HealthBarOutline, "Filled", true)
                    setrenderproperty(Self.Renders.HealthBarOutline, "Visible", false)
                    -- Value
                    setrenderproperty(Self.Renders.HealthBarValue, "Size", 13)
                    setrenderproperty(Self.Renders.HealthBarValue, "Center", false)
                    setrenderproperty(Self.Renders.HealthBarValue, "Outline", true)
                    setrenderproperty(Self.Renders.HealthBarValue, "Font", 2)
                    setrenderproperty(Self.Renders.HealthBarValue, "Visible", false)
                end
                --
                do -- Renders.Distance
                    setrenderproperty(Self.Renders.Distance, "Size", 13)
                    setrenderproperty(Self.Renders.Distance, "Center", true)
                    setrenderproperty(Self.Renders.Distance, "Outline", true)
                    setrenderproperty(Self.Renders.Distance, "Font", 2)
                    setrenderproperty(Self.Renders.Distance, "Visible", false)
                end
                --
                do -- Renders.Weapon
                    setrenderproperty(Self.Renders.Weapon, "Size", 13)
                    setrenderproperty(Self.Renders.Weapon, "Center", true)
                    setrenderproperty(Self.Renders.Weapon, "Outline", true)
                    setrenderproperty(Self.Renders.Weapon, "Font", 2)
                    setrenderproperty(Self.Renders.Weapon, "Visible", false)
                end
                --
                Visuals.Bases[Properties.Player] = Self
                --
                return Self
            end
        end
    end
    --
    function Visuals:Update()
        local MouseLocation = Utility:MousePosition(true)
        --
        if (Flags["VisualsFOV_AimAssist"]:Get()) and (Flags["LegitAimAssist_Enabled"]:Get()) and (Flags["LegitAimAssist_MaxFOV"]:Get()) then
            local AimAssistColor1, AimAssistTransparency1 = Color3.fromHex("#38afa3"), 0.65
            local AimAssistColor2, AimAssistTransparency2 = Color3.fromHex("#38c8c8"), 0.75
            local FieldOfView = Lotti.Locals.VisualAimAssistFOV / 2
            --
            setrenderproperty(Visuals.AimAssistCircle, "Position", MouseLocation)
            setrenderproperty(Visuals.AimAssistCircle, "Color", AimAssistColor1)
            setrenderproperty(Visuals.AimAssistCircle, "Transparency", 1 - AimAssistTransparency1)
            setrenderproperty(Visuals.AimAssistCircle, "Radius", FieldOfView)
            setrenderproperty(Visuals.AimAssistCircle, "NumSides", 60)
            setrenderproperty(Visuals.AimAssistCircle, "Visible", true)
            --
            setrenderproperty(Visuals.AimAssistOutline, "Position", MouseLocation)
            setrenderproperty(Visuals.AimAssistOutline, "Color", AimAssistColor2)
            setrenderproperty(Visuals.AimAssistOutline, "Transparency", 1 - AimAssistTransparency2)
            setrenderproperty(Visuals.AimAssistOutline, "Radius", FieldOfView)
            setrenderproperty(Visuals.AimAssistOutline, "NumSides", 60)
            setrenderproperty(Visuals.AimAssistOutline, "Visible", true)
        else
            setrenderproperty(Visuals.AimAssistCircle, "Visible", false)
            setrenderproperty(Visuals.AimAssistOutline, "Visible", false)
        end
        --
        if (Flags["VisualsFOV_Deadzone"]:Get()) and (Flags["LegitAimAssist_Enabled"]:Get()) and (Flags["LegitAimAssist_DeadzoneAmmount"]:Get() > 0) and (Flags["LegitAimAssist_MaxFOV"]:Get()) then
            local DeadzoneColor1, DeadzoneTransparency1 = Color3.fromHex("#050c0f"), 0.65
            local DeadzoneColor2, DeadzoneTransparency2 = Color3.fromHex("#0a0f14"), 0.75
            local FieldOfView = Lotti.Locals.VisualDeadzoneFOV / 2
            --
            setrenderproperty(Visuals.DeadzoneCircle, "Position", MouseLocation)
            setrenderproperty(Visuals.DeadzoneCircle, "Color", DeadzoneColor1)
            setrenderproperty(Visuals.DeadzoneCircle, "Transparency", 1 - DeadzoneTransparency1)
            setrenderproperty(Visuals.DeadzoneCircle, "Radius", FieldOfView)
            setrenderproperty(Visuals.DeadzoneCircle, "NumSides", 60)
            setrenderproperty(Visuals.DeadzoneCircle, "Visible", true)
            --
            setrenderproperty(Visuals.DeadzoneOutline, "Position", MouseLocation)
            setrenderproperty(Visuals.DeadzoneOutline, "Color", DeadzoneColor2)
            setrenderproperty(Visuals.DeadzoneOutline, "Transparency", 1 - DeadzoneTransparency2)
            setrenderproperty(Visuals.DeadzoneOutline, "Radius", FieldOfView)
            setrenderproperty(Visuals.DeadzoneOutline, "NumSides", 60)
            setrenderproperty(Visuals.DeadzoneOutline, "Visible", true)
        else
            setrenderproperty(Visuals.DeadzoneCircle, "Visible", false)
            setrenderproperty(Visuals.DeadzoneOutline, "Visible", false)
        end
    end
    --
    function Visuals:Unload()
        --
        for Index = 1, 2 do
            local Circle = Index == 1 and "AimAssist" or "Deadzone"
            DestroyRenderObject(Visuals[Circle .. "Circle"])
            DestroyRenderObject(Visuals[Circle .. "Outline"])
        end
    end
    --
    function Visuals.Base:Remove()
        local Self = self
        --
        if Self then
            setmetatable(Self, {})
            --
            Visuals.Bases[Self.Player] = nil
            --
            Self.Object = nil
            --
            for Index, Value in pairs(Self.Renders) do
                DestroyRenderObject(Value)
            end
            --
            Self.Renders = nil
            Self = nil
        end
    end
    --
    function Visuals.Base:Opacity(State, Table)
        local Self = self
        --
        if Self then
            local Renders = rawget(Self, "Renders")
            --
            for Index, Value in pairs(typeof(Table) == "table" and Table or Renders) do
                setrenderproperty(typeof(Table) == "table" and Renders[Value] or Value, "Visible", State)
            end
            --
            if not State then
                Self.Info.RootPartCFrame = nil
                Self.Info.Health = nil
                Self.Info.MaxHealth = nil
                Self.Info.BoundingBox = nil
            end
        end
    end
    --
    function Visuals.Base:Update()
        local Self = self
        --
        if Self then
            local Renders = rawget(Self, "Renders")
            local Player = rawget(Self, "Player")
            local Info = rawget(Self, "Info")
            local Parent = Lotti:GetPlayerParent(Player)
            --
            if (Player and Parent and Parent ~= nil) or (Info.RootPartCFrame and Info.Health and Info.MaxHealth) then
                local Selection = ((Player == Client) and "Local" or Lotti:CheckTeam(Client, Player) and "Enemies" or "Friendlies")
                --
                if (Flags["PlayersESP_Enabled"]:Get()) and (Flags["PlayersESP_" .. Selection]:Get()) then
                    local Override = (Selection == "Enemies" and Color3.fromHex("#ff0000") or Selection == "Friendlies" and Color3.fromHex("#00ff00") or Selection == "Local" and Color3.fromHex("#ff00ff"))
                    local Object, Humanoid, RootPart = Lotti:ValidateClient(Player)
                    local BodyParts = (RootPart and Lotti:GetBodyParts(Object, RootPart, true))
                    local TransparencyMultplier = 1
                    --
                    if Object and Object.Parent and (Humanoid and RootPart and BodyParts) then
                        local Health, MaxHealth = Lotti:GetHealth(Player, Object, Humanoid)
                        --
                        Info.Pass = true
                        Info.RootPartCFrame = RootPart.CFrame
                        Info.Health = Health
                        Info.MaxHealth = MaxHealth
                    else
                        Info.Pass = false
                    end
                    --
                    if Info.Pass then
                        Info.Tick = tick()
                    else
                        local FadeTime = 250 / 1000
                        local Value = Info.Tick - tick()
                        --
                        if Value <= FadeTime then
                            TransparencyMultplier = Clamp((Value + FadeTime) * 1 / FadeTime, 0, 1)
                        else
                            Info.RootPartCFrame = nil
                            Info.Health = nil
                            Info.MaxHealth = nil
                            Info.BoundingBox = nil
                        end
                    end
                    --
                    if Info.RootPartCFrame and Info.Health and Info.MaxHealth then
                        local Magnitude = (Workspace.CurrentCamera.CFrame.Position - Info.RootPartCFrame.Position).Magnitude
                        local Distance = Magnitude
                        local Position, OnScreen = Workspace.CurrentCamera:WorldToViewportPoint(Info.RootPartCFrame.Position)
                        --
                        local BoxSize
                        local BoxPosition 
                        --
                        if OnScreen then
                            local MaxDistance = tonumber(Flags["PlayersESP_MaxDistance"]:Get())
                            --
                            if Magnitude <= MaxDistance then
                                local BoundingBox = (Info.Pass and {Lotti:GetBoundingBox(BodyParts, RootPart)} or Info.BoundingBox)
                                local Width = (Workspace.CurrentCamera.CFrame - Workspace.CurrentCamera.CFrame.Position) * Vector3.new((Clamp(BoundingBox[2].X, 1, 10) + 0.5) / 2, 0, 0)
                                local Height = (Workspace.CurrentCamera.CFrame - Workspace.CurrentCamera.CFrame.Position) * Vector3.new(0, (Clamp(BoundingBox[2].Y, 1, 10) + 0.5) / 2, 0)
                                --
                                if Info.Pass then
                                    Info.BoundingBox = BoundingBox
                                end
                                --
                                local Middle = Workspace.CurrentCamera:WorldToViewportPoint(BoundingBox[1].Position)
                                Width = Abs(Workspace.CurrentCamera:WorldToViewportPoint(BoundingBox[1].Position + Width).X - Workspace.CurrentCamera:WorldToViewportPoint(BoundingBox[1].Position - Width).X)
                                Height = Abs(Workspace.CurrentCamera:WorldToViewportPoint(BoundingBox[1].Position + Height).Y - Workspace.CurrentCamera:WorldToViewportPoint(BoundingBox[1].Position - Height).Y)
                                --
                                BoxSize = Math:RoundVector(Vector2.new(Width, Height))
                                BoxPosition = Math:RoundVector(Vector2.new(Middle.X, Middle.Y) - (BoxSize / 2))
                                --
                                do -- Box
                                    if (Flags["PlayersESP_BoundingBox"]:Get()) then
                                        local BoxColor1, BoxTransparency1 = Override, ((1 - 0.2) * TransparencyMultplier)
                                        local BoxColor2, BoxTransparency2 = Override, ((1 - 0.8) * TransparencyMultplier)
                                        -- Inline
                                        setrenderproperty(Renders.BoxInline, "Size", BoxSize)
                                        setrenderproperty(Renders.BoxInline, "Position", BoxPosition)
                                        setrenderproperty(Renders.BoxInline, "Visible", true)
                                        setrenderproperty(Renders.BoxInline, "Color", BoxColor1)
                                        setrenderproperty(Renders.BoxInline, "Transparency", BoxTransparency1)
                                        -- Outline
                                        setrenderproperty(Renders.BoxOutline, "Size", BoxSize)
                                        setrenderproperty(Renders.BoxOutline, "Position", BoxPosition)
                                        setrenderproperty(Renders.BoxOutline, "Visible", true)
                                        setrenderproperty(Renders.BoxOutline, "Transparency", BoxTransparency1)
                                        -- Fill
                                        setrenderproperty(Renders.BoxFill, "Size", BoxSize)
                                        setrenderproperty(Renders.BoxFill, "Position", BoxPosition)
                                        setrenderproperty(Renders.BoxFill, "Visible", true)
                                        setrenderproperty(Renders.BoxFill, "Color", BoxColor2)
                                        setrenderproperty(Renders.BoxFill, "Transparency", BoxTransparency2)
                                    else
                                        setrenderproperty(Renders.BoxInline, "Visible", false)
                                        setrenderproperty(Renders.BoxOutline, "Visible", false)
                                        setrenderproperty(Renders.BoxFill, "Visible", false)
                                    end
                                end
                            end
                        end
                        --
                        if BoxSize and BoxPosition then
                            local ArrowTypes
                            --
                            do -- Name
                                local NameEnabled
                                --
                                if ArrowTypes then
                                    NameEnabled = Find(ArrowTypes, "Name")
                                else
                                    NameEnabled = (Flags["PlayersESP_Name"]:Get())
                                end
                                --
                                if NameEnabled then
                                    local NameColor, NameTransparency = Color3.fromHex("#ffffff"), ((1 - 0.2) * TransparencyMultplier)
                                    --
                                    local Text = "[" .. Player.Name .. "]"
                                    --
                                    setrenderproperty(Renders.Name, "Text", Text)
                                    setrenderproperty(Renders.Name, "Position", BoxPosition + Vector2.new(BoxSize.X / 2, -(13 + 4)))
                                    setrenderproperty(Renders.Name, "Visible", true)
                                    setrenderproperty(Renders.Name, "Color", NameColor)
                                    setrenderproperty(Renders.Name, "Transparency", NameTransparency)
                                else
                                    setrenderproperty(Renders.Name, "Visible", false)
                                end
                            end 
                            --
                            do -- HeatlhBar
                                local HealthBarColor1, HealthBarTransparency = Color3.fromHex("#00ff00"), ((1 - 0.2) * TransparencyMultplier)
                                local HealthBarColor2 = Color3.fromHex("#ff0000")
                                local HealthBarEnabled
                                local HealthNumEnabled
                                --
                                if ArrowTypes then
                                    HealthBarEnabled = Find(ArrowTypes, "Health Bar")
                                    HealthNumEnabled = Find(ArrowTypes, "Health Number")
                                else
                                    HealthBarEnabled = (Flags["PlayersESP_HealthBar"]:Get())
                                    HealthNumEnabled = (Flags["PlayersESP_HealthNumber"]:Get())
                                end
                                --
                                local HealthSize = (Floor(BoxSize.Y * (Info.Health / Info.MaxHealth)))
                                local Color = Color:Lerp(Info.Health / Info.MaxHealth, HealthBarColor1, HealthBarColor2)
                                local Height = ((BoxPosition.Y + BoxSize.Y) - HealthSize)
                                --
                                if HealthBarEnabled then
                                    -- Inline
                                    setrenderproperty(Renders.HealthBarInline, "Color", Color)
                                    setrenderproperty(Renders.HealthBarInline, "Size", Vector2.new(2, HealthSize))
                                    setrenderproperty(Renders.HealthBarInline, "Position", Vector2.new(BoxPosition.X - 5, Height))
                                    setrenderproperty(Renders.HealthBarInline, "Visible", true)
                                    setrenderproperty(Renders.HealthBarInline, "Transparency", HealthBarTransparency)
                                    -- Outline
                                    setrenderproperty(Renders.HealthBarOutline, "Size", Vector2.new(4, BoxSize.Y + 2))
                                    setrenderproperty(Renders.HealthBarOutline, "Position", Vector2.new(BoxPosition.X - 6, BoxPosition.Y - 1))
                                    setrenderproperty(Renders.HealthBarOutline, "Visible", true)
                                    setrenderproperty(Renders.HealthBarOutline, "Transparency", HealthBarTransparency)
                                else
                                    setrenderproperty(Renders.HealthBarInline, "Visible", false)
                                    setrenderproperty(Renders.HealthBarOutline, "Visible", false)
                                end
                                --
                                if HealthNumEnabled then
                                    -- Value
                                    local Text = Utility:ClampString(tostring(Round(Info.Health)), BoxSize.Y)
                                    --
                                    setrenderproperty(Renders.HealthBarValue, "Text", Text)
                                    setrenderproperty(Renders.HealthBarValue, "Color", Color)
                                    setrenderproperty(Renders.HealthBarValue, "Position", Vector2.new(BoxPosition.X - (HealthBarEnabled and 8 or 4) - (#Text * 8), Clamp(Height, 0, Height + HealthSize - (HealthSize > 13 and 13 or 0))))
                                    setrenderproperty(Renders.HealthBarValue, "Visible", true)
                                    setrenderproperty(Renders.HealthBarValue, "Transparency", HealthBarTransparency)
                                else
                                    setrenderproperty(Renders.HealthBarValue, "Visible", false)
                                end
                            end
                            --
                            local DistanceEnabled
                            --
                            do -- Distance
                                if ArrowTypes then
                                    DistanceEnabled = Find(ArrowTypes, "Distance")
                                else
                                    DistanceEnabled = (Flags["PlayersESP_Distance"]:Get())
                                end
                                --
                                if DistanceEnabled then
                                    local DistanceColor, DistanceTransparency = Color3.fromHex("#ffffff"), ((1 - 0.4) * TransparencyMultplier)
                                    --
                                    setrenderproperty(Renders.Distance, "Text", ("%s%s"):format(math.round(Magnitude), "st"))
                                    setrenderproperty(Renders.Distance, "Position", BoxPosition + Vector2.new(BoxSize.X / 2, (BoxSize.Y + 4)))
                                    setrenderproperty(Renders.Distance, "Visible", true)
                                    setrenderproperty(Renders.Distance, "Color", DistanceColor)
                                    setrenderproperty(Renders.Distance, "Transparency", DistanceTransparency)
                                else
                                    setrenderproperty(Renders.Distance, "Visible", false)
                                end
                            end
                            --
                            do -- Weapon
                                local WeaponEnabled
                                --
                                if ArrowTypes then
                                    WeaponEnabled = Find(ArrowTypes, "Tool")
                                else
                                    WeaponEnabled = (Flags["PlayersESP_Tool"]:Get())
                                end
                                --
                                if WeaponEnabled then
                                    local WeaponColor, WeaponTransparency = Color3.fromHex("#ffffff"), ((1 - 0.4) * TransparencyMultplier)
                                    --
                                    setrenderproperty(Renders.Weapon, "Text", ("%s"):format("None"))
                                    setrenderproperty(Renders.Weapon, "Position", BoxPosition + Vector2.new(BoxSize.X / 2, (BoxSize.Y + 4 + (DistanceEnabled and 13 or 0))))
                                    setrenderproperty(Renders.Weapon, "Visible", true)
                                    setrenderproperty(Renders.Weapon, "Color", WeaponColor)
                                    setrenderproperty(Renders.Weapon, "Transparency", WeaponTransparency)
                                else
                                    setrenderproperty(Renders.Weapon, "Visible", false)
                                end
                            end
                            --
                            return
                        end
                    end
                end
                --
                return Self:Opacity(false)
            end
            --
            return Self:Remove()
        end
    end
end
-- // UI Init
do -- UI
    local Window = Library:New({Name = "x11.solutions", Style = 1, PageAmmount = 4, Size = Vector2.new(602,629)});
    local Aimbot = Window:Page({Name = "Legitbot"}); do
        local AimAssist = Aimbot:Section({Name = "Aim Assist", Fill = true}); do
            AimAssist:Toggle({Name = "Enabled", Pointer = "LegitAimAssist_Enabled"}):Keybind({Pointer = "LegitAimAssist_EnabledKey", Default = Enum.UserInputType.MouseButton2, Mode = "On Hold", KeybindName = "Aim Assist"});
            AimAssist:Slider({Name = "Horizontal Smoothing", Pointer = "LegitAimAssist_HorizontalSmoothing", Min = 0, Max = 100, Default = 10, Decimals = 0.1, Suffix = "%"});
            AimAssist:Slider({Name = "Vertical Smoothing", Pointer = "LegitAimAssist_VerticalSmoothing", Min = 0, Max = 100, Default = 10, Decimals = 0.1, Suffix = "%"});
            AimAssist:Toggle({Name = "Max FOV", Pointer = "LegitAimAssist_MaxFOV"});
            AimAssist:Slider({Name = "FOV Amount", Pointer = "LegitAimAssist_FieldOfView", Min = 0, Max = 100, Default = 10, Decimals = 0.1, Suffix = "%"});
            AimAssist:Dropdown({Name = "FOV Type", Pointer = "LegitAimAssist_FOVType", Options = {"Static","Dynamic"}, Default = "Static"});
            AimAssist:Multibox({Name = "Aim Bone", Pointer = "LegitAimAssist_Hitbox", Options = {"Head", "Torso", "Arms", "Legs"}, Default = {"Head"}, Min = 1, Max = 4});
            AimAssist:Dropdown({Name = "Aim By", Pointer = "LegitAimAssist_HitscanType", Options = {"Crosshair", "Distance", "Health"}, Default = "Crosshair"});
            AimAssist:Multibox({Name = "Aim Assist Checks", Pointer = "LegitAimAssist_Checks", Options = {"Team Check", "Wall Check", "Visible Check", "ForceField Check", "Alive Check"}, Default = {}, Min = 0, Max = 5});
            AimAssist:Dropdown({Name = "Wall Check Origin", Pointer = "LegitAimAssist_WallCheckOrigin", Options = {"Camera", "Head", "Torso"}, Default = "Camera"});
            AimAssist:Toggle({Name = "Readjustment", Pointer = "LegitAimAssist_Readjustment"});
            AimAssist:Slider({Name = "Deadzone", Pointer = "LegitAimAssist_DeadzoneAmmount", Min = 0, Max = 100, Default = 10, Decimals = 0.1, Suffix = "%", Disable = {"Disabled", 0, 100}});
            AimAssist:Slider({Name = "Stutter", Pointer = "LegitAimAssist_Stutter", Min = 0, Max = 100, Default = 10, Decimals = 0.1, Suffix = "t", Disable = {"Disabled", 0, 100}});
        end;
        --
        local TriggerBot = Aimbot:Section({Name = "Triggerbot", Side = "Right", Size = 256}); do
            TriggerBot:Toggle({Name = "Enabled", Pointer = "LegitTriggerbot_Enabled"}):Keybind({Pointer = "LegitTriggerbot_EnabledKey", Mode = "On Hold", KeybindName = "Trigger Bot"});
            TriggerBot:Slider({Name = "Delay", Pointer = "LegitTriggerbot_Delay", Min = 0, Max = 500, Default = 10, Decimals = 0.1, Suffix = "ms"});
            TriggerBot:Slider({Name = "Interval", Pointer = "LegitTriggerbot_Interval", Min = 0, Max = 100, Default = 75, Decimals = 1, Suffix = "ms"});
            TriggerBot:Multibox({Name = "Aim Bone", Pointer = "LegitTriggerbot_Hitbox", Options = {"Head", "Torso", "Arms", "Legs"}, Default = {"Head"}, Min = 1, Max = 4});
            TriggerBot:Multibox({Name = "Triggerbot Checks", Pointer = "LegitTriggerbot_Checks", Options = {"Team Check", "Wall Check", "Visible Check", "ForceField Check", "Alive Check"}, Default = {}, Min = 0, Max = 5});
            TriggerBot:Dropdown({Name = "Wall Check Origin", Pointer = "LegitTriggerbot_WallCheckOrigin", Options = {"Camera", "Head", "Torso"}, Default = "Camera"});
            TriggerBot:Toggle({Name = "Readjustment", Pointer = "LegitTriggerbot_Readjustment"});
        end;
            -- JERMAINE
        local Misc, HitboxExpansion = Aimbot:MultiSection({Fill = true, Sections = {"Cursor Offset", "Hitbox Expansion"}, Side = "Right"}); do
            Misc:Toggle({Name = "Cursor Offset", Pointer = "LegitMisc_CursorOffset"});
            Misc:Slider({Pointer = "LegitMisc_CursorOffsetX", Min = -100, Max = 100, Default = 0, Decimals = 0.1, Suffix = "px"});
            Misc:Slider({Pointer = "LegitMisc_CursorOffsetY", Min = -100, Max = 100, Default = 0, Decimals = 0.1, Suffix = "px"});
            HitboxExpansion:Toggle({Name = "Torso Expander / Legit", Default = false, Callback = function(State) getgenv().Expander2 = State  
                RunService.Heartbeat:Connect(function()
                   if Expander2 == true then
                      for i,v in pairs(Players:GetPlayers()) do
                        if v.Name ~= Player.Name then
                            pcall(function()
                                v.Character.HumanoidRootPart.Size = Vector3.new(ExpanderSize2,ExpanderSize2,ExpanderSize2)
                                v.Character.HumanoidRootPart.Transparency = ExpanderTransparency2
                                v.Character.HumanoidRootPart.CanCollide = false
                                end)
                            end 
                        end
                        else
                            for i,v in pairs(Players:GetPlayers()) do
                                if v.Name ~= Player.Name then
                                    pcall(function()
                                        v.Character.HumanoidRootPart.Size = Vector3.new(2,2,1)
                                        v.Character.HumanoidRootPart.Transparency = 0
                                        v.Character.HumanoidRootPart.CanCollide = false
                                    end)
                                end
                            end
                        end
                    end)    
                end})
                HitboxExpansion:Slider({Name = "Hitbox Size", Default = 1, Min = 1, Max = 6.3, Decimals = 0.1, Suffix = "px", Callback = function(State) getgenv().ExpanderSize = State end})
                HitboxExpansion:Slider({Name = "Hitbox Transparency", Default = 0.5, Min = 0, Max = 1, Decimals = 0.1, Suffix = "%", Callback = function(State) getgenv().ExpanderTransparency = State end})
            HitboxExpansion:Toggle({Name = "Head Expander / Risky", Default = false, Callback = function(State) getgenv().Expander = State  
                    RunService.Heartbeat:Connect(function()
                       if Expander == true then
                          for i,v in pairs(Players:GetPlayers()) do
                            if v.Name ~= Player.Name then
                                pcall(function()
                                    local face = v.Character.Head:FindFirstChild("face")
                                    v.Character.Head.Size = Vector3.new(ExpanderSize,ExpanderSize,ExpanderSize)
                                    v.Character.Head.Transparency = ExpanderTransparency
                                    v.Character.Head.CanCollide = false
                                        if face then 
                                            face.Transparency = ExpanderTransparency
                                        end
                                    end)
                                end 
                            end
                            else
                                for i,v in pairs(Players:GetPlayers()) do
                                    if v.Name ~= Player.Name then
                                        pcall(function()
                                            local face = v.Character.Head:FindFirstChild("face")
                                            v.Character.Head.Size = Vector3.new(1.1978397369384766, 1.2024002075195312, 1.1979007720947266)
                                            v.Character.Head.Transparency = 0
                                            v.Character.Head.CanCollide = false
                                            if face then 
                                                face.Transparency = 0
                                            end
                                        end)
                                    end
                                end
                            end
                        end)    
                    end})     
                    HitboxExpansion:Slider({Name = "Hitbox Size", Default = 1, Min = 1, Max = 50, Decimals = 0.1, Suffix = "px", Callback = function(State) getgenv().ExpanderSize = State end})
                    HitboxExpansion:Slider({Name = "Hitbox Transparency", Default = 0.5, Min = 0, Max = 1, Decimals = 0.1, Suffix = "%", Callback = function(State) getgenv().ExpanderTransparency = State end})
                end;
             end;

    --[[
    local Misc = Window:Page({Name = "Miscellaneous"});  
        local MiscStuff, MoreMisc = Misc:MultiSection({Fill = false, Sections = {"Teleports","Remotes"}, Side = "Left", Size = 200})]]
    --
    local Visuals = Window:Page({Name = "Players"}); do
        local ESP = Visuals:Section({Name = "Visuals", Fill = true}); do
            ESP:Toggle({Name = "Enabled", Pointer = "PlayersESP_Enabled"});
            ESP:Toggle({Name = "Name", Pointer = "PlayersESP_Name"})--:Colorpicker({default = Color3.fromRGB(255,255,255)});
            ESP:Toggle({Name = "Bounding Box", Pointer = "PlayersESP_BoundingBox"})--:Colorpicker({default = Color3.fromRGB(255,255,255)});
            ESP:Toggle({Name = "Health Bar", Pointer = "PlayersESP_HealthBar"})--:Colorpicker({default = Color3.fromRGB(255,255,255)});
            ESP:Toggle({Name = "Health Number", Pointer = "PlayersESP_HealthNumber"});
            ESP:Toggle({Name = "Distance", Pointer = "PlayersESP_Distance"});
            ESP:Toggle({Name = "Tool", Pointer = "PlayersESP_Tool"});
            ESP:Toggle({Name = "Enemies", Pointer = "PlayersESP_Enemies"});
            ESP:Toggle({Name = "Friendlies", Pointer = "PlayersESP_Friendlies"});
            ESP:Toggle({Name = "Local", Pointer = "PlayersESP_Local"});
            ESP:Slider({Name = "Max Distance", Pointer = "PlayersESP_MaxDistance", Min = 0, Max = 5000, Default = 1000});
        end;
        --
        local Misc = Visuals:Section({Name = "Misc", Fill = true, Side = "Right"}); do
            Misc:Toggle({Name = "Draw FOV", Pointer = "VisualsFOV_AimAssist"});
            Misc:Toggle({Name = "Draw Deadzone", Pointer = "VisualsFOV_Deadzone"});

            --Additional:Button({Name = "Copy Join Script", Callback = function() setclipboard(([[game:GetService("TeleportService"):TeleportToPlaceInstance(%s, "%s")]]):format(game.PlaceId, game.JobId)) end});
        end;
    end;
    -- 







    --[[ local args = {
            [1] = "Faction_Broker",
            [2] = "LSVBroker",
            [3] = {
                ["Item"] = "M1911A1"
            }
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Economy"):FireServer(unpack(args))]]

        -- local Config, Theme = Settings:MultiSection({Fill = true, Sections = {"Config","Theme"}, Side = "Right"});


    local Misc = Window:Page({Name = "Miscellaneous"});  
        local MiscStuff, MoreMisc = Misc:MultiSection({Fill = false, Sections = {"Teleports","Remotes"}, Side = "Left", Size = 200})
            
        
        MoreMisc:Button({Name = "M1911", Callback = function() local args = {[1] = "Faction Broker", [2] = "LSVBroker", [3] = {["Item"] = "M1911A1"}} game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Economy"):FireServer(unpack(args)) end})
        MoreMisc:Button({Name = "MAC-10", Callback = function() local args = {[1] = "Faction Broker", [2] = "LSVBroker", [3] = {["Item"] = "Mac 10"}} game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Economy"):FireServer(unpack(args)) end})
        MoreMisc:Button({Name = "TEC-9", Callback = function() local args = {[1] = "Faction Broker", [2] = "LSVBroker", [3] = {["Item"] = "Tec 9"}} game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Economy"):FireServer(unpack(args)) end})
        MoreMisc:Button({Name = "Ithaca-37", Callback = function() local args = {[1] = "Faction Broker", [2] = "LSVBroker", [3] = {["Item"] = "Ithaca 37"}} game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Economy"):FireServer(unpack(args)) end})
        MoreMisc:Button({Name = ".38 Snubnose", Callback = function() local args = {[1] = "Faction Broker", [2] = "LSVBroker", [3] = {["Item"] = ".38 Snubnose"}} game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Economy"):FireServer(unpack(args)) end})
        MoreMisc:Button({Name = "Sawed Off", Callback = function() local args = {[1] = "Faction Broker", [2] = "LSVBroker", [3] = {["Item"] = "Sawed Off"}} game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Economy"):FireServer(unpack(args)) end})
        MiscStuff:Button({Name = "Grove Street Territory", Callback = function() HumanoidRootPart.CFrame = CFrame.new(-1350.63513, 3.03564572, 1025.40601, -0.992912889, 1.69786052e-08, -0.118844502, 2.27758825e-08, 1, -4.74221551e-08, 0.118844502, -4.97928561e-08, -0.992912889)  end })
        MiscStuff:Button({Name = "Vagos Territory", Callback = function() HumanoidRootPart.CFrame = CFrame.new(-831.922729, 6.28031015, 844.812378, 0.999993384, -4.70636197e-09, -0.00363136642, 4.64849759e-09, 1, -1.59429838e-08, 0.00363136642, 1.59259983e-08, 0.999993384) end})
        MiscStuff:Button({Name = "Clothing Store", Callback = function() HumanoidRootPart.CFrame = CFrame.new(-735.504456, 3.4253633, 538.842041, -0.99998945, -9.80870585e-09, -0.00458991621, -9.34995992e-09, 1, -9.9967906e-08, 0.00458991621, -9.99239376e-08, -0.99998945) end})
        MiscStuff:Button({Name = "Burger Joint", Callback = function()  HumanoidRootPart.CFrame = CFrame.new(-1060.59766, 3.47174335, 507.864624, 2.88626015e-05, -1.40735594e-07, -1, 9.52116275e-10, 1, -1.40735565e-07, 1, -9.48054302e-10, 2.88626015e-05)  end})
        MiscStuff:Button({Name = "Car Dealership", Callback = function() HumanoidRootPart.CFrame = CFrame.new(-913.249817, 3.01114583, 220.515579, -0.999437869, 4.47828583e-08, 0.0335261524, 4.35715961e-08, 1, -3.68594613e-08, -0.0335261524, -3.53779548e-08, -0.999437869) end})
        MiscStuff:Button({Name = "Jail", Callback = function() HumanoidRootPart.CFrame = CFrame.new(-658.400452, 18.3120365, 2002.53394, 0.0323273912, 5.96750649e-09, 0.999477327, -1.08473166e-07, 1, -2.46213894e-09, -0.999477327, -1.08336877e-07, 0.0323273912)  end})
        MiscStuff:Button({Name = "City Area", Callback = function() HumanoidRootPart.CFrame = CFrame.new(1764.79468, 3.4324913, 478.970795, 0.0238266718, 3.1793352e-08, 0.999716103, 5.33097655e-09, 1, -3.19294351e-08, -0.999716103, 6.09023543e-09, 0.0238266718) end})
        
    --
    local Settings = Window:Page({Name = "Configuration"}); do
        local PlayerList = Settings:PlayerList({});
        local themes = {
            Default = {
                accent = Color3.fromRGB(50, 43, 143),
                lightcontrast = Color3.fromRGB(32,32,32),
                darkcontrast = Color3.fromRGB(25,25,25),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(45,45,45),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Nebula = {
                accent = Color3.fromRGB(192, 76, 255),
                lightcontrast = Color3.fromRGB(17,19,23),
                darkcontrast = Color3.fromRGB(15,17,19),
                outline = Color3.fromRGB(31,29,29),
                inline = Color3.fromRGB(0, 0, 0),
                textcolor = Color3.fromRGB(192, 192, 192),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Neko = {
                accent = Color3.fromRGB(226, 30, 112),
                lightcontrast = Color3.fromRGB(18,18,18),
                darkcontrast = Color3.fromRGB(15,15,15),
                outline = Color3.fromRGB(0, 0, 0),
                inline = Color3.fromRGB(50, 50, 50),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Spotify = {
                accent = Color3.fromRGB(77, 255, 138),
                lightcontrast = Color3.fromRGB(18,18,18),
                darkcontrast = Color3.fromRGB(15,15,15),
                outline = Color3.fromRGB(0, 0, 0),
                inline = Color3.fromRGB(50, 50, 50),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Fatality = {
                accent = Color3.fromRGB(197, 7, 84),
                lightcontrast = Color3.fromRGB(30,24,66),
                darkcontrast = Color3.fromRGB(25, 19, 53),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(60, 53, 93),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            ["Tokyo Night"] = {
                accent = Color3.fromRGB(103, 89, 179),
                lightcontrast = Color3.fromRGB(25, 25, 37),
                darkcontrast = Color3.fromRGB(22, 22, 31),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(50, 50, 50),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            ["Kiriot Hub"] = {
                accent = Color3.fromRGB(255, 170, 0),
                lightcontrast = Color3.fromRGB(48, 51, 59),
                darkcontrast = Color3.fromRGB(26, 28, 32),
                outline = Color3.fromRGB(40, 40, 40),
                inline = Color3.fromRGB(0, 0, 0),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Jester = {
                accent = Color3.fromRGB(219, 68, 103),
                lightcontrast = Color3.fromRGB(36, 36, 36),
                darkcontrast = Color3.fromRGB(28, 28, 28),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(55, 55, 55),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Entrophy = {
                accent = Color3.fromRGB(143,181,214),
                lightcontrast = Color3.fromRGB(45,44,50),
                darkcontrast = Color3.fromRGB(37,37,42),
                outline = Color3.fromRGB(16,16,20),
                inline = Color3.fromRGB(68,67,76),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Interwebz = {
                accent = Color3.fromRGB(247, 123, 101),
                lightcontrast = Color3.fromRGB(32,25,43),
                darkcontrast = Color3.fromRGB(25,18,34),
                outline = Color3.fromRGB(26,20,36),
                inline = Color3.fromRGB(48,42,57),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Aimware = {
                accent = Color3.fromRGB(240, 72, 78),
                lightcontrast = Color3.fromRGB(31,31,31),
                darkcontrast = Color3.fromRGB(19,19,19),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(52,51,55),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            ["Dark Lagoon"] = {
                accent = Color3.fromRGB(41, 92, 168),
                lightcontrast = Color3.fromRGB(38, 43, 60),
                darkcontrast = Color3.fromRGB(32,35,51),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(44, 54, 90),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Onetap = {
                accent = Color3.fromRGB(255,153,54),
                lightcontrast = Color3.fromRGB(46,46,46),
                darkcontrast = Color3.fromRGB(30,30,30),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(67,67,67),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Abyss = {
                accent = Color3.fromRGB(122,130,241),
                lightcontrast = Color3.fromRGB(32,32,32),
                darkcontrast = Color3.fromRGB(25,25,25),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(45,45,45),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Vape = {
                accent = Color3.fromRGB(32,110,87),
                lightcontrast = Color3.fromRGB(32,32,32),
                darkcontrast = Color3.fromRGB(25,25,25),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(45,45,45),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Gamesense = {
                accent = Color3.fromRGB(140,181,67),
                lightcontrast = Color3.fromRGB(23,23,23),
                darkcontrast = Color3.fromRGB(12,12,12),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(58,60,65),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Neverlose = {
                accent = Color3.fromRGB(83,198,131),
                lightcontrast = Color3.fromRGB(0,15,30),
                darkcontrast = Color3.fromRGB(3,4,16),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(13,24,37),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
            Primordial = {
                accent = Color3.fromRGB(194,155,165),
                lightcontrast = Color3.fromRGB(21,21,21),
                darkcontrast = Color3.fromRGB(31,31,31),
                outline = Color3.fromRGB(0,0,0),
                inline = Color3.fromRGB(67,67,67),
                textcolor = Color3.fromRGB(255, 255, 255),
                textdark = Color3.fromRGB(175, 175, 175),
                textborder = Color3.fromRGB(0, 0, 0),
                riskytext = Color3.new(1, 1, 0.5),
                cursoroutline = Color3.fromRGB(10, 10, 10)
            };
        };
        local themeStrings = {}
        for i,v in next, themes do
            table.insert(themeStrings, i)
        end
        --
        local Menu = Settings:Section({Name = "Menu", Size = 90}); do
            Menu:Keybind({Name = "Open / Close", Pointer = "SettingsMenu_CloseKey", Default = Enum.KeyCode.End, Mode = "Toggle", callback = function(State) Window.uibind = State end});
            Menu:Toggle({Name = "Custom Menu Name", Pointer = "SettingsMenu_CustomName", Callback = function(State)
                if State then
                    Window:SetName(Library.pointers["SettingsMenu_CustomNameValue"]:Get())
                else
                    Window:SetName("x11.solutions");
                end
            end});
            Menu:TextBox({Pointer = "SettingsMenu_CustomNameValue", Default = "Lotti", PlaceHolder = "Custom Name Here", Callback = function(State)
                if Library.pointers["SettingsMenu_CustomName"]:Get() then
                    Window:SetName(State)
                else
                    Window:SetName("x11.solutions");
                end
            end})
        end;
        --
        local Additional = Settings:Section({Name = "Additional", Size = 141}); do
            Additional:Toggle({Name = "Keybind List", Pointer = "SettingsAdditional_Keybinds", Callback = function(State) Window.keybindslist:Update("Visible", State) end});
            Additional:Button({Name = "Rejoin Server", Callback = function() game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId) end});
            Additional:Button({Name = "Copy Join Script", Callback = function() setclipboard(([[game:GetService("TeleportService"):TeleportToPlaceInstance(%s, "%s")]]):format(game.PlaceId, game.JobId)) end});
        end;
        --
        local Config, Theme = Settings:MultiSection({Fill = true, Sections = {"Config","Theme"}, Side = "Right"}); do
            Theme:Colorpicker({Name = "Accent", Pointer = "SettingsMenu_Accent", Default = Color3.fromRGB(55, 175, 225), Callback = function(State) Library:UpdateColor("Accent", State) end});
            Theme:Colorpicker({Name = "Light Contrast", Pointer = "SettingsMenu_LightContrast", Default = Color3.fromRGB(30, 30, 30), Callback = function(State) Library:UpdateColor("LightContrast", State) end});
            Theme:Colorpicker({Name = "Dark Contrast", Pointer = "SettingsMenu_DarkContrast", Default = Color3.fromRGB(20,20,20), Callback = function(State) Library:UpdateColor("DarkContrast", State) end});
            Theme:Colorpicker({Name = "Inline", Pointer = "SettingsMenu_Inline", Default = Color3.fromRGB(50, 50, 50), Callback = function(State) Library:UpdateColor("Inline", State) end});
            Theme:Colorpicker({Name = "Outline", Pointer = "SettingsMenu_Outline", Default = Color3.fromRGB(0, 0, 0), Callback = function(State) Library:UpdateColor("Outline", State) end});
            Theme:Colorpicker({Name = "Text Color", Pointer = "SettingsMenu_TextColor", Default = Color3.fromRGB(255,255,255), Callback = function(State) Library:UpdateColor("TextColor", State) end});
            Theme:Colorpicker({Name = "Text Dark", Pointer = "SettingsMenu_TextDark", Default = Color3.fromRGB(175,175,175), Callback = function(State) Library:UpdateColor("TextDark", State) end});
            Theme:Colorpicker({Name = "Text Border", Pointer = "SettingsMenu_TextBorder", Default = Color3.fromRGB(0, 0, 0), Callback = function(State) Library:UpdateColor("TextBorder", State) end});
            Theme:Dropdown({Name = "Theme", Pointer = "SettingsMenu_Theme", Options = themeStrings, Max = 8});
            Theme:Button({Name = "Load Theme", Callback = function()
                local selected_theme = Library.pointers["SettingsMenu_Theme"]:Get();
                if selected_theme then
                    Library.pointers["SettingsMenu_Accent"]:Set(themes[selected_theme].accent)
                    Library.pointers["SettingsMenu_LightContrast"]:Set(themes[selected_theme].lightcontrast)
                    Library.pointers["SettingsMenu_DarkContrast"]:Set(themes[selected_theme].darkcontrast)
                    Library.pointers["SettingsMenu_Outline"]:Set(themes[selected_theme].outline)
                    Library.pointers["SettingsMenu_Inline"]:Set(themes[selected_theme].inline)
                    Library.pointers["SettingsMenu_TextColor"]:Set(themes[selected_theme].textcolor)
                    Library.pointers["SettingsMenu_TextDark"]:Set(themes[selected_theme].textdark)
                    Library.pointers["SettingsMenu_TextBorder"]:Set(themes[selected_theme].textborder)
                end
            end});
            local ConfigName = Config:TextBox({Pointer = "SettingsConfig_Name", PlaceHolder = "Config Name Here"})
            --
            Config:ButtonHolder({buttons = {{"Create", function()
                local config_name = Flags["SettingsConfig_Name"]:Get()
                if config_name == "" or isfile("Lotti/Configs/" .. config_name .. ".txt") then
                    return
                end
                writefile("Lotti/Configs/" .. config_name .. ".txt", "")
            end}, {"Delete", function()
                local config_name = Flags["SettingsConfig_Name"]:Get()
                if config_name and isfile("Lotti/Configs/" .. config_name .. ".txt") then
                    delfile("Lotti/Configs/" .. config_name .. ".txt")
                end
            end}}})
            Config:ButtonHolder({buttons = {{"Load", function()
                local config_name = Flags["SettingsConfig_Name"]:Get()
                if config_name and isfile("Lotti/Configs/" .. config_name .. ".txt") then
                    Window:LoadConfig(readfile("Lotti/Configs/" .. config_name .. ".txt"))
                end
            end}, {"Save", function()
                local config_name = Flags["SettingsConfig_Name"]:Get()
                if config_name and isfile("Lotti/Configs/" .. config_name .. ".txt") then
                    writefile("Lotti/Configs/" .. config_name .. ".txt", Window:GetConfig())
                end
            end}}})
        end
    end;
    --
    Window:Initialize();
end
-- Connections
Utility:Connection(RunService.RenderStepped, function()
    for Index, Value in pairs(Visuals.Bases) do
        Value:Update()
    end
    --
    local AimAssist = (Flags["LegitAimAssist_Enabled"]:Get())
    --
    if AimAssist then
        Utility:ThreadFunction(Lotti.UpdateFieldOfView, "2x01")
    end
    --
    if AimAssist and Flags["LegitAimAssist_EnabledKey"]:Active() and not Utility:ReadjustmentActive((Flags["LegitAimAssist_Readjustment"]:Get())) then
        Utility:ThreadFunction(Lotti.GetAimAssistTarget, "2x02")
        Utility:ThreadFunction(Lotti.AimAssist, "2x03")
    else
        Lotti.Locals.PossibleTarget = nil
        Lotti.Locals.Target = nil
    end
    --
    if (Flags["LegitTriggerbot_Enabled"]:Get()) and Flags["LegitTriggerbot_EnabledKey"]:Active() and not Utility:ReadjustmentActive((Flags["LegitTriggerbot_Readjustment"]:Get())) then
        Utility:ThreadFunction(Lotti.GetTriggerBotTarget, "2x04")
        Utility:ThreadFunction(Lotti.TriggerBot, "2x05")
    else
        Lotti.Locals.TriggerTarget = nil
    end
    --
    Utility:ThreadFunction(Visuals.Update, "3x01")
end)
--
Utility:Connection(Players.PlayerAdded, function(Player)
    Lotti:PlayerAdded(Player)
end)
--
for Index, Player in pairs(Lotti:GetPlayers()) do
    Lotti:PlayerAdded(Player)
end
return Visuals
